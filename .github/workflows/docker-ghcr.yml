name: GHCR Docker image

on:
  push:
    paths-ignore:
    - 'examples/**'
    - '**.md'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: node64_client

jobs:
  container:
    name: Build Container
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: Check out repository code
        uses: actions/checkout@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest Tag
        uses: actions-ecosystem/action-get-latest-tag@v1
        id: get-latest-tag

      - name: Collect Infos
        id: vars
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
          echo "START_IMAGE_NAME=${IMAGE_NAME}" >>${GITHUB_ENV}
          echo "IMAGE_NAME=${GITHUB_REPOSITORY_OWNER,,}/${IMAGE_NAME,,}" >>${GITHUB_ENV}
          versionGit=${{ steps.get-latest-tag.outputs.tag }}
          versionPY=v$(grep 'Version = ' Node64Client/__init__.py | cut -d'=' -f2 | xargs)
          if [ "$versionGit" != "$versionPY" -a $(git tag | grep -c "$versionPY") -eq 0 ]; then
            echo "version=$versionPY" >> $GITHUB_OUTPUT
            echo "createtag=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "version=$versionGit" >> $GITHUB_OUTPUT
          echo "createtag=false" >> $GITHUB_OUTPUT

      - name: create Version tag
        if: steps.vars.outputs.createtag == 'true'
        uses: actions/github-script@v5
        with:
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/${{ steps.vars.outputs.version }},
              sha: context.sha
            })
            
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          labels: |
            org.opencontainers.image.revision=${{ steps.vars.outputs.version }}
            org.opencontainers.image.licenses=GPL-2.0
            org.opencontainers.image.vendor=ipv64net

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        
      - name: Build and push Docker Branch not main
        if: ${{ github.ref != format('refs/heads/{0}', 'main') }}
        uses: docker/build-push-action@v4
        with:
          build-args: |
            METHOD=package
            VERSION=${{ steps.vars.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          context: .
          file: devices/Docker/Dockerfile
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}_${{ steps.vars.outputs.branch }}:${{ steps.vars.outputs.sha_short }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}_${{ steps.vars.outputs.branch }}:${{ steps.vars.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}_${{ steps.vars.outputs.branch }}:latest

      - name: Build and push Docker main branch
        if: ${{ github.ref == format('refs/heads/{0}', 'main') }}
        uses: docker/build-push-action@v4
        with:
          build-args: |
            METHOD=package
            VERSION=${{ steps.vars.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          context: .
          file: devices/Docker/Dockerfile
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.sha_short }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      # - name: CleanUp ${{ env.START_IMAGE_NAME }} Package
      #   if: ${{ github.ref == format('refs/heads/{0}', 'main') }}
      #   uses: actions/github-script@v3
      #   with:
      #     github-token: ${{ secrets.DELETE_PACKAGES_TOKEN }}
      #     script: |
      #       try {
      #         const response = await github.request("GET /${{ env.OWNER }}/packages/container/${{ env.PACKAGE_NAME }}/versions",
      #           { per_page: ${{ env.PER_PAGE }}
      #         });
      #         for(version of response.data) {
      #             if (version.metadata.container.tags.length == 0) {
      #               try {
      #                 console.log("try delete " + version.id)
      #                 const deleteResponse = await github.request("DELETE /${{ env.OWNER }}/packages/container/${{ env.PACKAGE_NAME }}/versions/" + version.id, { });
      #                 console.log("status " + deleteResponse.status)
      #               } catch (error) {
      #                 console.log(`cant delete: ` + deleteResponse.status);
      #               }

      #             }
      #         }
      #       } catch (error) {
      #         console.log(`Error URL: ` + error);
      #       }
      #   env:
      #     OWNER: user # or orgs/<org name>
      #     PACKAGE_NAME: ${{ env.START_IMAGE_NAME }}
      #     PER_PAGE: 100

      # - name: CleanUp ${{ env.START_IMAGE_NAME }}_${{ steps.vars.outputs.branch }} Package
      #   if: ${{ github.ref != format('refs/heads/{0}', 'main') }}
      #   uses: actions/github-script@v3
      #   with:
      #     github-token: ${{ secrets.DELETE_PACKAGES_TOKEN }}
      #     script: |
      #       try {
      #         const response = await github.request("GET /${{ env.OWNER }}/packages/container/${{ env.PACKAGE_NAME }}/versions",
      #           { per_page: ${{ env.PER_PAGE }}
      #         });
      #         for(version of response.data) {
      #             if (version.metadata.container.tags.length == 0) {
      #               try {
      #                 console.log("try delete " + version.id)
      #                 const deleteResponse = await github.request("DELETE /${{ env.OWNER }}/packages/container/${{ env.PACKAGE_NAME }}/versions/" + version.id, { });
      #                 console.log("status " + deleteResponse.status)
      #               } catch (error) {
      #                 console.log(`cant delete: ` + deleteResponse.status);
      #               }

      #             }
      #         }
      #       } catch (error) {
      #         console.log(`Error URL: ` + error);
      #       }
      #   env:
      #     OWNER: user # or orgs/<org name>
      #     PACKAGE_NAME: ${{ env.START_IMAGE_NAME }}_${{ steps.vars.outputs.branch }}
      #     PER_PAGE: 100
